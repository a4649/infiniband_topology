<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
    stroke: #fff;
    stroke-width: 1.5px;
}

.faded {
    opacity: 0.2;
    stroke-width: 0.2px;
}

.highlight {
    font-weight: bold;
    stroke-width: 2px;
}

.link {
    stroke: #999;
    stroke-opacity: 1;
    fill: none;
    /*stroke-width: 1;*/
}

.nodename {
    font-size: 10px;
}

div {
    position: absolute;
    top: 10px;
    left: 10px;
}

svg {
    width: 100%;
    height: 100%;
}

body, html {
    height: 100%;
    width: 100%;
}

</style>
<div id="infoview">
    <table>
        <tr>
            <td id="name" colspan=2 style="font-weight: bold;">stage12</td>
        </tr>
        <tr>
            <td>Guid:</td>
            <td id="guid">48294820480</td>
        </tr>
        <tr>
            <td>Type:</td>
            <td id="type">switch</td>
        </tr>
        <tr>
            <td>Ports (connected):</td>
            <td id="portcount">36 (27)</td>
        </tr>
        <tr>
            <td>Connected nodes:</td>
            <td id="connections">36</td>
        </tr>
    </table>
</div>
<svg id="chart"></svg>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
//Define some global variables
var svg = d3.select("#chart")
var width  = svg.style('width').replace('px','');
var height = svg.style('height').replace('px','');

//Set up the colour scale
var color = d3.scale.category20();

//The scales for implementing zoom, every coordinate used for
//drawing will have to go through these.
var xzoom = d3.scale.linear()
    .domain([0,width])
    .range([0,width]);

var yzoom = d3.scale.linear()
    .domain([0,height])
    .range([0,height]);

//Assign the zoom behaviour to our SVG object.
//The zoom behavior makes changes to our xzoom and yzoom scales based on
//user input and calls the updateCoordinates function to update the coordinates
//of our graph based on these updated scales.
svg.call(d3.behavior.zoom()
        .x(xzoom)
        .y(yzoom)
        .scaleExtent([0.1,8])
        .on("zoom", updateCoordinates))
        //Do not "zoom" on double-click
        .on('dblclick.zoom', null)

//On window resize, we want the graph to also resize, so we have to update
//the zoom scales, the force layout size and update all the coordinates of our elements.
window.onresize = function(){
    width = window.innerWidth;
    height = window.innerHeight;
    force.size([width,height]);
    xzoom.range([0,width]);
    yzoom.range([0,height]);
    updateCoordinates();
}

//Set up the force layout
var force = d3.layout.force()
    .charge(-1000)
    .linkDistance(50)
    .size([width, height])
    .on("tick", updateCoordinates);

//Make the nodes draggable
var drag = force.drag()
    //Once a node's been dragged it will stay fixed
    .on('dragstart', function(d){
        d.fixed = true;

        //Do not propagate the drag event to svg element, which would
        //activate the zoom behavior's drag event and pan the entire view
        d3.event.sourceEvent.stopPropagation();
    })
    .on('dragend', function(d){
    })
    .on('drag', function(d){

    })


//Variables to hold the different components of our graph
//we declare them here so they can be accessed from different functions
var link, circle, text

//This will contain the currently selected node, used to display
//connectivity
var selectedNode = null;

//This function will update the coordinates of our nodes and links
//based on the data. This basically carries out the layout animation
//as it is used for the tick function of the force layout
function updateCoordinates() {
    // link.attr("x1", function (d) {
    //     return xzoom(d.source.x);
    // })
    // .attr("y1", function (d) {
    //     return yzoom(d.source.y);
    // })
    // .attr("x2", function (d) {
    //     return xzoom(d.target.x);
    // })
    // .attr("y2", function (d) {
    //     return yzoom(d.target.y);
    // });

    //We draw the links as curved paths, with the radius of the curve
    //being dependant on the distance between the nodes
    link.attr('d', function(d){
        var src_x = xzoom(d.source.x);
        var src_y = yzoom(d.source.y);
        var dst_x = xzoom(d.target.x);
        var dst_y = yzoom(d.target.y);

        var dx = dst_x - src_x;
        var dy = dst_y - src_y;

        //The radius is also dependant of the "rank" of the link
        dr = Math.sqrt(dx*dx + dy*dy)*d.rank;

        //And we alternate the "direction" of the curve for even and odd ranks
        //The direction can be altered by swapping the endpoints of the curve.
        if(d.rank%2==0){
            var swap=src_x;
            src_x=dst_x;
            dst_x=swap;

            swap=src_y;
            src_y=dst_y;
            dst_y=swap;
        }
        return "M" + 
            src_x + "," + 
            src_y + "A" +
            dr + "," + dr + " 0 0,1 " +
            dst_x + "," +
            dst_y;
    })

    //Causes some weird yanking when dragging a node
    // node.attr('transform', function(d) {
    //     return 'translate(' + d.x + ',' + d.y +')'
    // })

    //Changing the coordinates of the circle and text
    //separately makes dragging smooth.
    circle.attr("cx", function (d) {
        return xzoom(d.x);
    })
    .attr("cy", function (d) {
        return yzoom(d.y);
    });

    text.attr("x", function (d) {
        return xzoom(d.x);
    })
    .attr("y", function (d) {
        return yzoom(d.y);
    });

}

//We load the topology data from file as JSON
d3.json("topo.json", function(error, topoData){
    //Each node has a unique GUID, we use it to index the nodes for
    //accessing them later on
    nodeindex={}
    for(var i=0; i < topoData.nodes.length; i++){
        node = topoData.nodes[i];
        nodeindex[node.guid] = node;
        node.connections={}
        // node.available_ports=2;
        node.connected_nodes=0;
        // node.connected_ports=0;
    }
    //For each link we create references to nodes at both sides,
    //this is needed by the force layout.
    //Also add to each node the GUID's of nodes they are connected to.
    //This is used later for visualizing directly connected nodes
    for(var i=0; i < topoData.links.length; i++){
        link = topoData.links[i];
        link.source = nodeindex[link.host1_guid];
        link.target = nodeindex[link.host2_guid];

        //We also add how many connections we have from each node to each node
        if(link.source.connections[link.target.guid])
            link.source.connections[link.target.guid]++;
        else{
            link.source.connections[link.target.guid]=1;
            link.source.connected_nodes++;
        }

        if(link.target.connections[link.source.guid])
            link.target.connections[link.source.guid]++;
        else{
            link.target.connections[link.source.guid]=1;
            link.target.connected_nodes++;
        }
        // link.target.connected_ports++;
        // link.source.connected_ports++;

        //The rank on the link will symbolize what "nth" connection
        //between the same nodes this link is, this is used to visualize
        //many connections between the same two nodes in a visually pleasing way
        link.rank = link.source.connections[link.target.guid];
    }
    updateGraph({nodes:topoData.nodes,links:topoData.links});
});

function updateNodeinfo(node) {
    var info = d3.select('#infoview');
    info.select('#name').html(node.name);
    info.select('#guid').html('0x'+node.guid);
    info.select('#type').html(node.type);
    info.select('#portcount').html(node.available_ports+' ('+node.connected_ports+')');
    info.select('#connections').html(node.connected_nodes);
}
//This function takes care of drawing the graph once the data has been
//loaded and formatted correctly
function updateGraph(graph){
    //We add our nodes and links and start the force layout generation.
    force.nodes(graph.nodes)
        .links(graph.links)
        .start();

    //Create all the line svgs but without locations yet
    link = svg.selectAll(".link")
        .data(graph.links)
      .enter().append("path")
        .attr("class", "link");

    //A node is a g element containing a circle and some text
    var node = svg.selectAll(".node")
        .data(graph.nodes)
      .enter().append("g")
        .on('mouseover', function(){
            selectedNode=this.__data__.guid;

            node.classed({
                'faded': function(d) {
                    return !(d.guid==selectedNode || d.connections[selectedNode]);
                },
                'highlight': function(d) {
                    return d.guid==selectedNode || d.connections[selectedNode];
                }
            });
            link.classed({
                'faded': function(d){
                    return !(d.source.guid == selectedNode || 
                            d.target.guid == selectedNode);
                },
                'highlight': function(d){
                    return d.source.guid == selectedNode || 
                            d.target.guid == selectedNode;
                }
            });
            updateNodeinfo(this.__data__);
        })
        .on('dblclick', function(d){
            d.fixed=false;
        })
        .on('mouseout', function(){
            selectedNode = null;
            node.classed('faded',false);
            node.classed('highlight',false);
            link.classed('faded',false);
            link.classed('highlight',false);
        })
        .call(force.drag);
    
    circle = node.append('circle')
        .attr("class", "node")
        .attr("r", 8)
        .style("fill", function (d) {
            return color(d.type);
        })
    text = node.append('text')
        .text(function(d) { return d.name; })
        .attr('class', 'nodename')
        .attr('dx', 8)
        .attr('dy', ".35em")
}
</script>