<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
    stroke: #fff;
    stroke-width: 1.5px;
}

.faded {
    opacity: 0.2;
    stroke-width: 0.2px;
}

.highlight {
    font-weight: bold;
    stroke-width: 2px;
}

.link {
    stroke: #999;
    stroke-opacity: 1;
    /*stroke-width: 1;*/
}

.nodename {
    font-size: 10px;
}

svg {
    width: 100%;
    height: 100%;
}

body {
    height: 100%;
}

</style>
<svg id="chart"></svg>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
    //Constants for the SVG
    var svg = d3.select("#chart")
    var width  = svg.style('width').replace('px','');
    var height = svg.style('height').replace('px','');

    //Set up the colour scale
    var color = d3.scale.category20();

    var xzoom = d3.scale.linear()
        .domain([0,width])
        .range([0,width]);

    var yzoom = d3.scale.linear()
        .domain([0,height])
        .range([0,height]);

    //Append a SVG to the body of the html page. Assign this SVG as an object to svg
    
    svg.call(d3.behavior.zoom()
            .x(xzoom)
            .y(yzoom)
            .scaleExtent([0.1,8])
            .on("zoom", updateCoordinates))
            .on('dblclick.zoom', null)

    //Set up the force layout
    var force = d3.layout.force()
        .charge(-1000)
        .linkDistance(50)
        .size([width, height])
        .on("tick", updateCoordinates);

    var drag = force.drag()
        .on('dragstart', function(d){
            d.fixed = true;
            d3.event.sourceEvent.stopPropagation();
        })
        .on('dragend', function(d){
        })
        .on('drag', function(d){

        })



    var link, circle, text
    function updateCoordinates() {
        link.attr("x1", function (d) {
            return xzoom(d.source.x);
        })
        .attr("y1", function (d) {
            return yzoom(d.source.y);
        })
        .attr("x2", function (d) {
            return xzoom(d.target.x);
        })
        .attr("y2", function (d) {
            return yzoom(d.target.y);
        });

        //Causes some weird yanking when dragging a node
        // node.attr('transform', function(d) {
        //     return 'translate(' + d.x + ',' + d.y +')'
        // })

        //Changing the coordinates of the circle and text
        //separately makes dragging smooth.
        circle.attr("cx", function (d) {
            return xzoom(d.x);
        })
        .attr("cy", function (d) {
            return yzoom(d.y);
        });

        text.attr("x", function (d) {
            return xzoom(d.x);
        })
        .attr("y", function (d) {
            return yzoom(d.y);
        });

    }

    //We load the topology data from file as JSON
    d3.json("topo.json", function(error, topoData){
        nodeindex={}
        for(var i=0; i < topoData.nodes.length; i++){
            node = topoData.nodes[i];
            nodeindex[node.guid] = node;
            node.connections={}
        }
        for(var i=0; i < topoData.links.length; i++){
            link = topoData.links[i];
            link.source = nodeindex[link.host1_guid];
            link.target = nodeindex[link.host2_guid];
            link.source.connections[link.target.guid]=1;
            link.target.connections[link.source.guid]=1;
        }
        updateGraph({nodes:topoData.nodes,links:topoData.links});
    });

var selectedNode = null;
function updateGraph(graph){
    //Creates the graph data structure out of the json data
    force.nodes(graph.nodes)
        .links(graph.links)
        .start();

    //Create all the line svgs but without locations yet
    link = svg.selectAll(".link")
        .data(graph.links)
      .enter().append("line")
        .attr("class", "link");

    //Do the same with the circles for the nodes - no 
    var node = svg.selectAll(".node")
        .data(graph.nodes)
      .enter().append("g")
        .on('mouseover', function(){
            selectedNode=this.__data__.guid;

            node.classed({
                'faded': function(d) {
                    return !(d.guid==selectedNode || d.connections[selectedNode]);
                },
                'highlight': function(d) {
                    return d.guid==selectedNode || d.connections[selectedNode];
                }
            })
            link.classed({
                'faded': function(d){
                    return !(d.source.guid == selectedNode || 
                            d.target.guid == selectedNode);
                },
                'highlight': function(d){
                    return d.source.guid == selectedNode || 
                            d.target.guid == selectedNode;
                }
            })
        })
        .on('dblclick', function(d){
            d.fixed=false;
        })
        .on('mouseout', function(){
            selectedNode = null;
            node.classed('faded',false);
            node.classed('highlight',false);
            link.classed('faded',false);
            link.classed('highlight',false);
        })
        .call(force.drag);
    
    circle = node.append('circle')
        .attr("class", "node")
        .attr("r", 8)
        .style("fill", function (d) {
            return color(d.type);
        })
    text = node.append('text')
        .text(function(d) { return d.name; })
        .attr('class', 'nodename')
        .attr('dx', -50);
}
</script>